//
//  Upcaste Performance Libraries
//  Copyright (C) 2012 Jesse W. Towner
//
//  Permission is hereby granted, free of charge, to any person obtaining
//  a copy of this software and associated documentation files (the
//  "Software"), to deal in the Software without restriction, including
//  without limitation the rights to use, copy, modify, merge, publish,
//  distribute, sublicense, and/or sell copies of the Software, and to
//  permit persons to whom the Software is furnished to do so, subject to
//  the following conditions:
//
//  The above copyright notice and this permission notice shall be
//  included in all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
//  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
//  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
//  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
//  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

//
//  Do not edit! This file is automatically generated.
//

#ifndef UP_NUMERIC_GENERIC_FLOAT4_OPERATIONS_INL
#define UP_NUMERIC_GENERIC_FLOAT4_OPERATIONS_INL

namespace up { namespace math
{
    //
    // Constructor Bindings
    //

    namespace detail
    {
        template< >
        struct constructors<float4>
        {
            static UPALWAYSINLINE
            float4 load(float const* p) noexcept {
                float4 result;
                result.x = p[0];
                result.y = p[1];
                result.z = p[2];
                result.w = p[3];
                return result;
            }

            static UPALWAYSINLINE
            float4 load(size_t offset, float const* p) noexcept {
                float const* q = p + (offset * 4);
                float4 result;
                result.x = q[0];
                result.y = q[1];
                result.z = q[2];
                result.w = q[3];
                return result;
            }

            static UPALWAYSINLINE
            float4 loadunaligned(float const* p) noexcept {
                float4 result;
                result.x = p[0];
                result.y = p[1];
                result.z = p[2];
                result.w = p[3];
                return result;
            }

            static UPALWAYSINLINE
            float4 loadunaligned(size_t offset, float const* p) noexcept {
                float const* q = p + (offset * 4);
                float4 result;
                result.x = q[0];
                result.y = q[1];
                result.z = q[2];
                result.w = q[3];
                return result;
            }

            static UPALWAYSINLINE
            float4 loadreverse(float const* p) noexcept {
                float4 result;
                result.x = p[3];
                result.y = p[2];
                result.z = p[1];
                result.w = p[0];
                return result;
            }

            static UPALWAYSINLINE
            float4 loadreverse(size_t offset, float const* p) noexcept {
                float const* q = p + (offset * 4);
                float4 result;
                result.x = q[3];
                result.y = q[2];
                result.z = q[1];
                result.w = q[0];
                return result;
            }

            static UPALWAYSINLINE
            float4 loadscalar(float const* p) noexcept {
                float4 result;
                result.x = *p; result.y = result.z = result.w = 0.0f;
                return result;
            }

            static UPALWAYSINLINE
            float4 loadscalar(size_t offset, float const* p) noexcept {
                float4 result;
                result.x = *(p + offset); result.y = result.z = result.w = 0.0f;
                return result;
            }

            static UPALWAYSINLINE
            float4 make(float x) noexcept {
                float4 result;
                result.x = x; result.y = result.z = result.w = 0.0f;
                return result;
            }

            static UPALWAYSINLINE
            float4 make(float x, float y, float z, float w) noexcept {
                float4 result;
                result.x = x;
                result.y = y;
                result.z = z;
                result.w = w;
                return result;
            }

            static UPALWAYSINLINE
            float4 replicate(float value) noexcept {
                float4 result;
                result.x = result.y = result.z = result.w = value;
                return result;
            }

            static UPALWAYSINLINE
            float4 replicate(float const* p) noexcept {
                float4 result;
                result.x = result.y = result.z = result.w = *p;
                return result;
            }

            static UPALWAYSINLINE
            float4 replicate(size_t offset, float const* p) noexcept {
                float4 result;
                result.x = result.y = result.z = result.w = *(p + offset);
                return result;
            }

            static UPALWAYSINLINE
            float4 zero() noexcept {
                float4 result;
                result.x = result.y = result.z = result.w = 0.0f;
                return result;
            }
        };
    }

    //
    // Load / Store Functions
    //

    inline UPALWAYSINLINE
    float4 load(float4 const* p) noexcept {
        return *p;
    }

    inline UPALWAYSINLINE
    float4 load(size_t offset, float4 const* p) noexcept {
        return *(p + offset);
    }

    inline UPALWAYSINLINE
    float4 loadreverse(float4 const* p) noexcept {
        float4 result;
        result.x = p->w;
        result.y = p->z;
        result.z = p->y;
        result.w = p->x;
        return result;
    }

    inline UPALWAYSINLINE
    float4 loadreverse(size_t offset, float4 const* p) noexcept {
        float4 const* q = p + offset;
        float4 result;
        result.x = q->w;
        result.y = q->z;
        result.z = q->y;
        result.w = q->x;
        return result;
    }

    //
    // Accessor Functions
    //

    inline UPALWAYSINLINE
    float get(float4 const& v, size_t n) noexcept {
        return v.f[n];
    }

    inline UPALWAYSINLINE
    float getx(float4 const& v) noexcept {
        return v.x;
    }

    inline UPALWAYSINLINE
    float gety(float4 const& v) noexcept {
        return v.y;
    }

    inline UPALWAYSINLINE
    float getz(float4 const& v) noexcept {
        return v.z;
    }

    inline UPALWAYSINLINE
    float getw(float4 const& v) noexcept {
        return v.w;
    }

    inline UPALWAYSINLINE
    float4 put(float4 const& v, float value, size_t n) noexcept {
        float4 result = v;
        result.f[n] = value;
        return result;
    }

    inline UPALWAYSINLINE
    float4 putx(float4 const& v, float x) noexcept {
        float4 result;
        result.x = x;
        result.y = v.y;
        result.z = v.z;
        result.w = v.w;
        return result;
    }

    inline UPALWAYSINLINE
    float4 puty(float4 const& v, float y) noexcept {
        float4 result;
        result.x = v.x;
        result.y = y;
        result.z = v.z;
        result.w = v.w;
        return result;
    }

    inline UPALWAYSINLINE
    float4 putz(float4 const& v, float z) noexcept {
        float4 result;
        result.x = v.x;
        result.y = v.y;
        result.z = z;
        result.w = v.w;
        return result;
    }

    inline UPALWAYSINLINE
    float4 putw(float4 const& v, float w) noexcept {
        float4 result;
        result.x = v.x;
        result.y = v.y;
        result.z = v.z;
        result.w = w;
        return result;
    }

    inline UPALWAYSINLINE
    float4 splat(float4 const& v, size_t n) noexcept {
        float4 result;

        switch (n) {
        case 0: result.x = result.y = result.z = result.w = v.x; break;
        case 1: result.x = result.y = result.z = result.w = v.y; break;
        case 2: result.x = result.y = result.z = result.w = v.z; break;
        case 3: result.x = result.y = result.z = result.w = v.w; break;
        default: result = uniform<float4>::zero; break;
        }

        return result;
    }

    inline UPALWAYSINLINE
    float4 splatx(float4 const& v) noexcept {
        float4 result;
        result.x = v.x;
        result.y = v.x;
        result.z = v.x;
        result.w = v.x;
        return result;
    }

    inline UPALWAYSINLINE
    float4 splaty(float4 const& v) noexcept {
        float4 result;
        result.x = v.y;
        result.y = v.y;
        result.z = v.y;
        result.w = v.y;
        return result;
    }

    inline UPALWAYSINLINE
    float4 splatz(float4 const& v) noexcept {
        float4 result;
        result.x = v.z;
        result.y = v.z;
        result.z = v.z;
        result.w = v.z;
        return result;
    }

    inline UPALWAYSINLINE
    float4 splatw(float4 const& v) noexcept {
        float4 result;
        result.x = v.w;
        result.y = v.w;
        result.z = v.w;
        result.w = v.w;
        return result;
    }

    //
    // Relational Functions
    //

    inline UPALWAYSINLINE
    float4 isequal(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.u[0] = (v1.x == v2.x) ? 0xFFFFFFFFu : 0;
        result.u[1] = (v1.y == v2.y) ? 0xFFFFFFFFu : 0;
        result.u[2] = (v1.z == v2.z) ? 0xFFFFFFFFu : 0;
        result.u[3] = (v1.w == v2.w) ? 0xFFFFFFFFu : 0;
        return result;
    }

    inline UPALWAYSINLINE
    float4 isnotequal(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.u[0] = (v1.x != v2.x) ? 0xFFFFFFFFu : 0;
        result.u[1] = (v1.y != v2.y) ? 0xFFFFFFFFu : 0;
        result.u[2] = (v1.z != v2.z) ? 0xFFFFFFFFu : 0;
        result.u[3] = (v1.w != v2.w) ? 0xFFFFFFFFu : 0;
        return result;
    }

    inline UPALWAYSINLINE
    float4 isgreater(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.u[0] = (v1.x > v2.x) ? 0xFFFFFFFFu : 0;
        result.u[1] = (v1.y > v2.y) ? 0xFFFFFFFFu : 0;
        result.u[2] = (v1.z > v2.z) ? 0xFFFFFFFFu : 0;
        result.u[3] = (v1.w > v2.w) ? 0xFFFFFFFFu : 0;
        return result;
    }

    inline UPALWAYSINLINE
    float4 isgreaterequal(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.u[0] = (v1.x >= v2.x) ? 0xFFFFFFFFu : 0;
        result.u[1] = (v1.y >= v2.y) ? 0xFFFFFFFFu : 0;
        result.u[2] = (v1.z >= v2.z) ? 0xFFFFFFFFu : 0;
        result.u[3] = (v1.w >= v2.w) ? 0xFFFFFFFFu : 0;
        return result;
    }

    inline UPALWAYSINLINE
    float4 isless(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.u[0] = (v1.x < v2.x) ? 0xFFFFFFFFu : 0;
        result.u[1] = (v1.y < v2.y) ? 0xFFFFFFFFu : 0;
        result.u[2] = (v1.z < v2.z) ? 0xFFFFFFFFu : 0;
        result.u[3] = (v1.w < v2.w) ? 0xFFFFFFFFu : 0;
        return result;
    }

    inline UPALWAYSINLINE
    float4 islessequal(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.u[0] = (v1.x <= v2.x) ? 0xFFFFFFFFu : 0;
        result.u[1] = (v1.y <= v2.y) ? 0xFFFFFFFFu : 0;
        result.u[2] = (v1.z <= v2.z) ? 0xFFFFFFFFu : 0;
        result.u[3] = (v1.w <= v2.w) ? 0xFFFFFFFFu : 0;
        return result;
    }

    inline UPALWAYSINLINE
    float4 bitselect(float4 const& v1, float4 const& v2, float4 const& v3) noexcept {
        float4 result;
        result.u[0] = (v1.u[0] & v3.u[0]) | (v2.u[0] & ~v3.u[0]);
        result.u[1] = (v1.u[1] & v3.u[1]) | (v2.u[1] & ~v3.u[1]);
        result.u[2] = (v1.u[2] & v3.u[2]) | (v2.u[2] & ~v3.u[2]);
        result.u[3] = (v1.u[3] & v3.u[3]) | (v2.u[3] & ~v3.u[3]);
        return result;
    }

    inline UPALWAYSINLINE
    float4 select(float4 const& v1, float4 const& v2, float4 const& v3) noexcept {
        float4 result;
        result.f[0] = (v3.u[0] & 0x80000000u) ? v1.f[0] : v2.f[0];
        result.f[1] = (v3.u[1] & 0x80000000u) ? v1.f[1] : v2.f[1];
        result.f[2] = (v3.u[2] & 0x80000000u) ? v1.f[2] : v2.f[2];
        result.f[3] = (v3.u[3] & 0x80000000u) ? v1.f[3] : v2.f[3];
        return result;
    }

    //
    // Relational Operators
    //
    
    inline UPALWAYSINLINE
    bool operator==(float4 const& v1, float4 const& v2) noexcept {
        return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z) && (v1.w == v2.w);
    }
    
    inline UPALWAYSINLINE
    bool operator!=(float4 const& v1, float4 const& v2) noexcept {
        return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z) || (v1.w != v2.w);
    }
    
    inline UPALWAYSINLINE
    bool operator>(float4 const& v1, float4 const& v2) noexcept {
        return (v1.x > v2.x) && (v1.y > v2.y) && (v1.z > v2.z) && (v1.w > v2.w);
    }
    
    inline UPALWAYSINLINE
    bool operator>=(float4 const& v1, float4 const& v2) noexcept {
        return (v1.x >= v2.x) && (v1.y >= v2.y) && (v1.z >= v2.z) && (v1.w >= v2.w);
    }
    
    inline UPALWAYSINLINE
    bool operator<(float4 const& v1, float4 const& v2) noexcept {
        return (v1.x < v2.x) && (v1.y < v2.y) && (v1.z < v2.z) && (v1.w < v2.w);
    }
    
    inline UPALWAYSINLINE
    bool operator<=(float4 const& v1, float4 const& v2) noexcept {
        return (v1.x <= v2.x) && (v1.y <= v2.y) && (v1.z <= v2.z) && (v1.w <= v2.w);
    }

    //
    // Arithmetic Functions
    //
    
    inline UPALWAYSINLINE
    float4 add(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.x = v1.x + v2.x;
        result.y = v1.y + v2.y;
        result.z = v1.z + v2.z;
        result.w = v1.w + v2.w;
        return result;
    }
    
    inline UPALWAYSINLINE    
    float4 div(float4 const& v, float s) noexcept {    
        float4 result;
        result.x = v.x / s;
        result.y = v.y / s;
        result.z = v.z / s;
        result.w = v.w / s;
        return result;
    }
    
    inline UPALWAYSINLINE
    float4 div(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.x = v1.x / v2.x;
        result.y = v1.y / v2.y;
        result.z = v1.z / v2.z;
        result.w = v1.w / v2.w;
        return result;
    }
    
    inline UPALWAYSINLINE    
    float4 mul(float4 const& v, float s) noexcept {    
        float4 result;
        result.x = v.x * s;
        result.y = v.y * s;
        result.z = v.z * s;
        result.w = v.w * s;
        return result;
    }
    
    inline UPALWAYSINLINE
    float4 mul(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.x = v1.x * v2.x;
        result.y = v1.y * v2.y;
        result.z = v1.z * v2.z;
        result.w = v1.w * v2.w;
        return result;
    }
    
    inline UPALWAYSINLINE
    float4 neg(float4 const& v) noexcept {
        float4 result;
        result.x = -v.x;
        result.y = -v.y;
        result.z = -v.z;
        result.w = -v.w;
        return result;
    }
    
    inline UPALWAYSINLINE
    float4 sub(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.x = v1.x - v2.x;
        result.y = v1.y - v2.y;
        result.z = v1.z - v2.z;
        result.w = v1.w - v2.w;
        return result;
    }

    //
    // Arithmetic Operators
    //
    
    inline UPALWAYSINLINE
    float4 operator+(float4 const& v) noexcept {
        float4 result;
        result.x = +v.x;
        result.y = +v.y;
        result.z = +v.z;
        result.w = +v.w;
        return result;
    }
    
    inline UPALWAYSINLINE
    float4 operator+(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.x = v1.x + v2.x;
        result.y = v1.y + v2.y;
        result.z = v1.z + v2.z;
        result.w = v1.w + v2.w;
        return result;
    }
    
    inline UPALWAYSINLINE
    float4 operator-(float4 const& v) noexcept {
        float4 result;
        result.x = -v.x;
        result.y = -v.y;
        result.z = -v.z;
        result.w = -v.w;
        return result;
    }
    
    inline UPALWAYSINLINE
    float4 operator-(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.x = v1.x - v2.x;
        result.y = v1.y - v2.y;
        result.z = v1.z - v2.z;
        result.w = v1.w - v2.w;
        return result;
    }
    
    inline UPALWAYSINLINE    
    float4 operator*(float4 const& v, float s) noexcept {    
        float4 result;
        result.x = v.x * s;
        result.y = v.y * s;
        result.z = v.z * s;
        result.w = v.w * s;
        return result;
    }
    
    inline UPALWAYSINLINE
    float4 operator*(float s, float4 const& v) noexcept {    
        float4 result;
        result.x = v.x * s;
        result.y = v.y * s;
        result.z = v.z * s;
        result.w = v.w * s;
        return result;
    }
    
    inline UPALWAYSINLINE
    float4 operator*(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.x = v1.x * v2.x;
        result.y = v1.y * v2.y;
        result.z = v1.z * v2.z;
        result.w = v1.w * v2.w;
        return result;
    }
    
    inline UPALWAYSINLINE    
    float4 operator/(float4 const& v, float s) noexcept {    
        float4 result;
        result.x = v.x / s;
        result.y = v.y / s;
        result.z = v.z / s;
        result.w = v.w / s;
        return result;
    }
    
    inline UPALWAYSINLINE
    float4 operator/(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.x = v1.x / v2.x;
        result.y = v1.y / v2.y;
        result.z = v1.z / v2.z;
        result.w = v1.w / v2.w;
        return result;
    }

    //
    // Common Functions
    //

    inline UPALWAYSINLINE
    float4 clamp(float4 const& v, float4 const& v_min, float4 const& v_max) noexcept {
        float4 result;
        result.x = clamp(v.x, v_min.x, v_max.x);
        result.y = clamp(v.y, v_min.y, v_max.y);
        result.z = clamp(v.z, v_min.z, v_max.z);
        result.w = clamp(v.w, v_min.w, v_max.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 degrees(float4 const& v) noexcept {
        float4 result;
        result.x = v.x * FLT_DEGREES;
        result.y = v.y * FLT_DEGREES;
        result.z = v.z * FLT_DEGREES;
        result.w = v.w * FLT_DEGREES;
        return result;
    }

    inline UPALWAYSINLINE
    float4 max(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.x = fmax(v1.x, v2.x);
        result.y = fmax(v1.y, v2.y);
        result.z = fmax(v1.z, v2.z);
        result.w = fmax(v1.w, v2.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 min(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.x = fmin(v1.x, v2.x);
        result.y = fmin(v1.y, v2.y);
        result.z = fmin(v1.z, v2.z);
        result.w = fmin(v1.w, v2.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 mix(float4 const& v1, float4 const& v2, float t) noexcept {
        float4 result;
        result.x = v1.x + (t * (v2.x - v1.x));
        result.y = v1.y + (t * (v2.y - v1.y));
        result.z = v1.z + (t * (v2.z - v1.z));
        result.w = v1.w + (t * (v2.w - v1.w));
        return result;
    }

    inline UPALWAYSINLINE
    float4 mix(float4 const& v1, float4 const& v2, float4 const& t) noexcept {
        float4 result;
        result.x = v1.x + (t.x * (v2.x - v1.x));
        result.y = v1.y + (t.y * (v2.y - v1.y));
        result.z = v1.z + (t.z * (v2.z - v1.z));
        result.w = v1.w + (t.w * (v2.w - v1.w));
        return result;
    }

    inline UPALWAYSINLINE
    float4 radians(float4 const& v) noexcept {
        float4 result;
        result.x = v.x * FLT_RADIANS;
        result.y = v.y * FLT_RADIANS;
        result.z = v.z * FLT_RADIANS;
        result.w = v.w * FLT_RADIANS;
        return result;
    }

    inline UPALWAYSINLINE
    float4 saturate(float4 const& v) noexcept {
        float4 result;
        result.x = saturate(v.x);
        result.y = saturate(v.y);
        result.z = saturate(v.z);
        result.w = saturate(v.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 sign(float4 const& v) noexcept {
        float4 result;
        result.x = sign(v.x);
        result.y = sign(v.y);
        result.z = sign(v.z);
        result.w = sign(v.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 step(float edge, float4 const& v) noexcept {
        float4 result;
        result.x = (v.x < edge) ? 0.0f : 1.0f;
        result.y = (v.y < edge) ? 0.0f : 1.0f;
        result.z = (v.z < edge) ? 0.0f : 1.0f;
        result.w = (v.w < edge) ? 0.0f : 1.0f;
        return result;
    }

    inline UPALWAYSINLINE
    float4 step(float4 const& edge, float4 const& v) noexcept {
        float4 result;
        result.x = (v.x < edge.x) ? 0.0f : 1.0f;
        result.y = (v.y < edge.y) ? 0.0f : 1.0f;
        result.z = (v.z < edge.z) ? 0.0f : 1.0f;
        result.w = (v.w < edge.w) ? 0.0f : 1.0f;
        return result;
    }

    //
    // Mathematical Functions
    //

    inline UPALWAYSINLINE
    float4 ceil(float4 const& v) noexcept {
        float4 result;
        result.x = ceil(v.x);
        result.y = ceil(v.y);
        result.z = ceil(v.z);
        result.w = ceil(v.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 fabs(float4 const& v) noexcept {
        float4 result;
        result.x = fabs(v.x);
        result.y = fabs(v.y);
        result.z = fabs(v.z);
        result.w = fabs(v.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 fdim(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.x = fabs(v1.x - v2.x);
        result.y = fabs(v1.y - v2.y);
        result.z = fabs(v1.z - v2.z);
        result.w = fabs(v1.w - v2.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 floor(float4 const& v) noexcept {
        float4 result;
        result.x = floor(v.x);
        result.y = floor(v.y);
        result.z = floor(v.z);
        result.w = floor(v.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 fmax(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.x = fmax(v1.x, v2.x);
        result.y = fmax(v1.y, v2.y);
        result.z = fmax(v1.z, v2.z);
        result.w = fmax(v1.w, v2.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 fmin(float4 const& v1, float4 const& v2) noexcept {
        float4 result;
        result.x = fmin(v1.x, v2.x);
        result.y = fmin(v1.y, v2.y);
        result.z = fmin(v1.z, v2.z);
        result.w = fmin(v1.w, v2.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 mad(float4 const& v1, float4 const& v2, float4 const& v3) noexcept {
        float4 result;
        result.x = (v1.x * v2.x) + v3.x;
        result.y = (v1.y * v2.y) + v3.y;
        result.z = (v1.z * v2.z) + v3.z;
        result.w = (v1.w * v2.w) + v3.w;
        return result;
    }

    inline UPALWAYSINLINE
    float4 rcp(float4 const& v) noexcept {
        float4 result;
        result.x = rcp(v.x);
        result.y = rcp(v.y);
        result.z = rcp(v.z);
        result.w = rcp(v.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 rint(float4 const& v) noexcept {
        float4 result;
        result.x = rint(v.x);
        result.y = rint(v.y);
        result.z = rint(v.z);
        result.w = rint(v.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 round(float4 const& v) noexcept {
        float4 result;
        result.x = round(v.x);
        result.y = round(v.y);
        result.z = round(v.z);
        result.w = round(v.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 rsqrt(float4 const& v) noexcept {
        float4 result;
        result.x = rsqrt(v.x);
        result.y = rsqrt(v.y);
        result.z = rsqrt(v.z);
        result.w = rsqrt(v.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 sqrt(float4 const& v) noexcept {
        float4 result;
        result.x = sqrt(v.x);
        result.y = sqrt(v.y);
        result.z = sqrt(v.z);
        result.w = sqrt(v.w);
        return result;
    }

    inline UPALWAYSINLINE
    float4 trunc(float4 const& v) noexcept {
        float4 result;
        result.x = trunc(v.x);
        result.y = trunc(v.y);
        result.z = trunc(v.z);
        result.w = trunc(v.w);
        return result;
    }
}}

#endif
