//
//  Upcaste Performance Libraries
//  Copyright (C) 2012 Jesse W. Towner
//
//  Permission is hereby granted, free of charge, to any person obtaining
//  a copy of this software and associated documentation files (the
//  "Software"), to deal in the Software without restriction, including
//  without limitation the rights to use, copy, modify, merge, publish,
//  distribute, sublicense, and/or sell copies of the Software, and to
//  permit persons to whom the Software is furnished to do so, subject to
//  the following conditions:
//
//  The above copyright notice and this permission notice shall be
//  included in all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
//  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
//  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
//  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
//  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

//
//  Do not edit! This file is automatically generated.
//

#ifndef UP_MATH_GENERIC_SCALAR_OPERATIONS_INL
#define UP_MATH_GENERIC_SCALAR_OPERATIONS_INL

#ifndef UP_MATH_MATHFWD_HPP
#   error "Do not include this file directly! Instead include <up/math/mathfwd.hpp>"
#endif

namespace up { namespace math
{
    inline UPALWAYSINLINE UPPURE float fast_ceil(float x) noexcept { return ceil(x); };
    inline UPALWAYSINLINE UPPURE float fast_floor(float x) noexcept { return floor(x); };
    inline UPALWAYSINLINE UPPURE float fast_round(float x) noexcept { return round(x); };
    inline UPALWAYSINLINE UPPURE float fast_trunc(float x) noexcept { return trunc(x); };
    inline UPALWAYSINLINE UPPURE float fast_distance(float x, float y) noexcept { return fabs(y - x); }
    inline UPALWAYSINLINE UPPURE float fast_length(float x) noexcept { return fabs(x); }
    inline UPALWAYSINLINE UPPURE float fast_normalize(float) noexcept { return 1.0f; }
    inline UPALWAYSINLINE UPPURE float fast_rcp(float x) noexcept { return 1.0f / x; }
    inline UPALWAYSINLINE UPPURE float fast_rsqrt(float x) noexcept { return 1.0f / sqrt(x); }
}}

namespace up { namespace math { namespace detail
{
    template <class X, class Y, bool = std::is_floating_point<X>::value>
    struct generic_convert_sat_helper
    {
        static UPALWAYSINLINE UPPURE
        X convert(Y x) noexcept {
            typedef typename ::std::common_type<X, Y>::type ctype;
            ctype const r = static_cast<ctype>(x);

            if (r <= static_cast<ctype>(std::numeric_limits<X>::min())) {
                return ::std::numeric_limits<X>::min();
            }

            if (r >= static_cast<ctype>(std::numeric_limits<X>::max())) {
                return ::std::numeric_limits<X>::max();
            }

            return static_cast<X>(r);
        }
    };

    template <class X, class Y>
    struct generic_convert_sat_helper<X, Y, true>
    {
        static UPALWAYSINLINE UPPURE
        X convert(Y x) noexcept {
            typedef typename ::std::common_type<X, Y>::type ctype;
            ctype const r = static_cast<ctype>(x);

            if (r <= static_cast<ctype>(-std::numeric_limits<X>::max())) {
                return -::std::numeric_limits<X>::max();
            }

            if (r >= static_cast<ctype>(std::numeric_limits<X>::max())) {
                return ::std::numeric_limits<X>::max();
            }

            return static_cast<X>(r);
        }
    };

    template <class To, class From>
    struct generic_convert_impl<To, From, 1, 1>
    {
        static UPALWAYSINLINE UPPURE
        To convert(From x) noexcept {
            return static_cast<To>(x);
        }
    };

    template <class To, class From>
    struct generic_convert_rte_impl<To, From, 1, 1>
    {
        static UPALWAYSINLINE UPPURE
        To convert(From x) noexcept {
            return static_cast<To>(round(x));
        }
    };

    template <class To, class From>
    struct generic_convert_rtz_impl<To, From, 1, 1>
    {
        static UPALWAYSINLINE UPPURE
        To convert(From x) noexcept {
            return static_cast<To>(trunc(x));
        }
    };

    template <class To, class From>
    struct generic_convert_rtn_impl<To, From, 1, 1>
    {
        static UPALWAYSINLINE UPPURE
        To convert(From x) noexcept {
            return static_cast<To>(floor(x));
        }
    };

    template <class To, class From>
    struct generic_convert_rtp_impl<To, From, 1, 1>
    {
        static UPALWAYSINLINE UPPURE
        To convert(From x) noexcept {
            return static_cast<To>(ceil(x));
        }
    };

    template <class To, class From>
    struct generic_convert_sat_impl<To, From, 1, 1> : generic_convert_sat_helper<To, From> { };

    template <class To, class From>
    struct generic_convert_sat_rte_impl<To, From, 1, 1>
    {
        static UPALWAYSINLINE UPPURE
        To convert(From x) noexcept {
            return ::up::math::convert_sat<To>(round(x));
        }
    };

    template <class To, class From>
    struct generic_convert_sat_rtz_impl<To, From, 1, 1>
    {
        static UPALWAYSINLINE UPPURE
        To convert(From x) noexcept {
            return ::up::math::convert_sat<To>(trunc(x));
        }
    };

    template <class To, class From>
    struct generic_convert_sat_rtn_impl<To, From, 1, 1>
    {
        static UPALWAYSINLINE UPPURE
        To convert(From x) noexcept {
            return ::up::math::convert_sat<To>(floor(x));
        }
    };

    template <class To, class From>
    struct generic_convert_sat_rtp_impl<To, From, 1, 1>
    {
        static UPALWAYSINLINE UPPURE
        To convert(From x) noexcept {
            return ::up::math::convert_sat<To>(ceil(x));
        }
    };
}}}

#endif
