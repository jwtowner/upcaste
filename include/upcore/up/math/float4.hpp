//
//  Upcaste Performance Libraries
//  Copyright (C) 2012-2013 Jesse W. Towner
//
//  Permission is hereby granted, free of charge, to any person obtaining
//  a copy of this software and associated documentation files (the
//  "Software"), to deal in the Software without restriction, including
//  without limitation the rights to use, copy, modify, merge, publish,
//  distribute, sublicense, and/or sell copies of the Software, and to
//  permit persons to whom the Software is furnished to do so, subject to
//  the following conditions:
//
//  The above copyright notice and this permission notice shall be
//  included in all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
//  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
//  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
//  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
//  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

//
//  Do not edit! This file is automatically generated.
//

#ifndef UP_MATH_FLOAT4_HPP
#define UP_MATH_FLOAT4_HPP

#include <up/math/int4.hpp>
#if defined(UP_SIMD_NEON)
#   include <up/math/neon/float4_operations.inl>
#elif defined(UP_SIMD_SSE_2)
#   include <up/math/sse/float4_operations.inl>
#else
#   include <up/math/generic/float4_operations.inl>
#endif

namespace up { namespace math
{
    //
    // Common Functions
    //
    
    inline UPALWAYSINLINE
    float4 degrees(float4_cval_t v) noexcept {
        return mul(v, uniform<float4>::degrees);
    }

    inline UPALWAYSINLINE
    float4 radians(float4_cval_t v) noexcept {
        return mul(v, uniform<float4>::radians);
    }

    inline UPALWAYSINLINE
    float4 step(float4_cval_t edge, float4_cval_t d) noexcept {
        int4 t;
        t = islessequal(edge, d); 
        t = bitwiseand(t, as<int4>(uniform<float4>::one));
        return as<float4>(t);
    }

    inline UPALWAYSINLINE
    float4 step(float const edge, float4_cval_t d) noexcept {
        return step(broadcast<float4>(edge), d);
    }

    inline UPALWAYSINLINE
    float4 smoothstep(float4_cval_t edge0, float4_cval_t edge1, float4_cval_t d) noexcept {
        float4 t, u, c0, c1, c2, c3;
        c0 = splatx(uniform<float4>::hermite_coefficients);
        c1 = splaty(uniform<float4>::hermite_coefficients);
        c2 = splatz(uniform<float4>::hermite_coefficients);
        c3 = splatw(uniform<float4>::hermite_coefficients);
        t = sub(d, edge0);
        u = sub(edge1, edge0);
        t = div(t, u);
        t = clamp(t, c0, c1);
        u = mul(t, t);
        t = fnma(t, c2, c3);
        return mul(t, u);
    }
    
    inline UPALWAYSINLINE
    float4 smoothstep(float const edge0, float const edge1, float4_cval_t d) noexcept {
        return smoothstep(broadcast<float4>(edge0), broadcast<float4>(edge1), d);
    }

    inline UPALWAYSINLINE
    float4 sign(float4_cval_t v) noexcept {
        int4 t;
        t = isnotequal(v, uniform<float4>::negative_zero);
        t = bitwiseand(t, as<int4>(uniform<float4>::one));
        return bitselect(as<float4>(t), v, uniform<float4>::negative_zero);
    }

    //
    // Mathematical Functions
    //

    inline UPALWAYSINLINE
    float4 copysign(float4_cval_t v1, float4_cval_t v2) noexcept {
        return bitselect(v1, v2, uniform<float4>::negative_zero);
    }

    inline UPALWAYSINLINE
    float4 fmod(float4_cval_t v1, float4_cval_t v2) noexcept {
       float4 r;
       r = div(v1, v2);
       r = trunc(r);
       r = fnma(r, v2, v1);
       return r;
    }

    inline UPALWAYSINLINE
    float4 wrap(float4_cval_t v1, float4_cval_t v2) noexcept {
       float4 r;
       r = div(v1, v2);
       r = floor(r);
       r = fnma(r, v2, v1);
       return r;
    }

    inline UPALWAYSINLINE
    float4 wrappi(float4_cval_t v) noexcept {
       float4 r;
       r = fma(v, uniform<float4>::reciprocal_two_pi, uniform<float4>::half);
       r = floor(r);
       r = fnma(r, uniform<float4>::two_pi, v);
       return r;
    }

    inline UPALWAYSINLINE
    float4 wrap2pi(float4_cval_t v) noexcept {
       float4 r;
       r = mul(v, uniform<float4>::reciprocal_two_pi);
       r = floor(r);
       r = fnma(r, uniform<float4>::two_pi, v);
       return r;
    }

    inline UPALWAYSINLINE
    float4 remainder(float4_cval_t v1, float4_cval_t v2) noexcept {
       float4 r;
       int4 m;
       r = div(v1, v2);
       r = round(r);
       r = fnma(r, v2, v1);
       m = isequal(r, uniform<float4>::negative_zero);
       r = select(r, uniform<float4>::negative_zero, m);
       return r;
    }

    inline UPALWAYSINLINE
    float4 native_cos(float4_cval_t v) noexcept {
        float4 const half_pi = splatx(uniform<float4>::sincos_range_constants);
        float4 const pi = splaty(uniform<float4>::sincos_range_constants);
        float4 const one = splatx(uniform<float4>::native_cos_coefficients);
        float4 const c1 = splaty(uniform<float4>::native_cos_coefficients);
        float4 const c2 = splatz(uniform<float4>::native_cos_coefficients);
        float4 const c3 = splatw(uniform<float4>::native_cos_coefficients);
        float4 r, s, t, u;
        int4 m;

        // decompose quadrant of u, let s = sign(cos(v)), let t = |u| reflected at Pi/2
        u = fabs(v);
        s = neg(one);
        m = islessequal(u, half_pi);
        t = sub(pi, u);
        s = select(s, one, m);
        t = select(t, u, m);

        // evaluate polynomial s*P(t) over [0,Pi/2] where P(t) = 1 + c1*t^2 + c2*t^4 + c3*t^6 + ...
        u = mul(t, t);
        t = mul(u, s);
        r = fma(c3, u, c2);
        r = fma(r, u, c1);
        r = fma(r, t, s);
        return r;
    }

    inline UPALWAYSINLINE
    float4 native_sin(float4_cval_t v) noexcept {
        float4 const half_pi = splatx(uniform<float4>::sincos_range_constants);
        float4 const pi = splaty(uniform<float4>::sincos_range_constants);
        float4 const one = splatx(uniform<float4>::native_sin_coefficients);
        float4 const c1 = splaty(uniform<float4>::native_sin_coefficients);
        float4 const c2 = splatz(uniform<float4>::native_sin_coefficients);
        float4 const c3 = splatw(uniform<float4>::native_sin_coefficients);
        float4 r, s, t, u;
        int4 m;

        // decompose quadrant of u, let s = sign(u), let t = |u| reflected at Pi/2
        s = copysign(one, v);
        u = fabs(v);
        m = islessequal(u, half_pi);
        t = sub(pi, u);
        t = select(t, u, m);

        // evaluate polynomial s*P(t) over [0,Pi/2] where P(t) = t + c1*t^3 + c2*t^5 + c3*t^7 + ...
        u = mul(t, t);
        t = mul(t, s);
        s = mul(u, t);
        r = fma(c3, u, c2);
        r = fma(r, u, c1);
        r = fma(r, s, t);
        return r; 
    }

    inline UPALWAYSINLINE
    float4 native_sincos(float4_cval_t v, float4* cosval) noexcept {
        float4 const half_pi = splatx(uniform<float4>::sincos_range_constants);
        float4 const pi = splaty(uniform<float4>::sincos_range_constants);
        float4 const one = splatx(uniform<float4>::native_sin_coefficients);
        float4 const c1 = splaty(uniform<float4>::native_cos_coefficients);
        float4 const c2 = splatz(uniform<float4>::native_cos_coefficients);
        float4 const c3 = splatw(uniform<float4>::native_cos_coefficients);
        float4 const s1 = splaty(uniform<float4>::native_sin_coefficients);
        float4 const s2 = splatz(uniform<float4>::native_sin_coefficients);
        float4 const s3 = splatw(uniform<float4>::native_sin_coefficients);
        float4 rs, rc, ss, sc, s, t, u;
        int4 m;

        // decompose quadrant of u, let s = sign(u), let t = |u| reflected at Pi/2
        ss = copysign(one, v);
        u = fabs(v);
        sc = neg(one); 
        m = islessequal(u, half_pi);
        t = sub(pi, u);
        sc = select(sc, one, m);
        t = select(t, u, m);

        // cos(v) = ss*Q(t) over [0,Pi/2] where Q(t) = t + c1*t^3 + c2*t^5 + c3*t^7 + ...
        // sin(v) = sc*P(t) over [0,Pi/2] where P(t) = 1 + c1*t^2 + c2*t^4 + c3*t^6 + ...
        u = mul(t, t);
        t = mul(t, ss);
        s = mul(u, sc);
        ss = mul(u, t);
        rc = fma(c3, u, c2);
        rs = fma(s3, u, s2);
        rc = fma(rc, u, c1);
        rs = fma(rs, u, s1);
        rc = fma(rc, s, sc);
        rs = fma(rs, ss, t);
        *cosval = rc;
        return rs;
    }

    inline UPALWAYSINLINE
    float4 native_tan(float4_cval_t v) noexcept {
        float4 const quarter_pi = splatx(uniform<float4>::tan_range_constants);
        float4 const half_pi = splaty(uniform<float4>::tan_range_constants);
        float4 const one = splatx(uniform<float4>::native_tan_coefficients0);
        float4 const t1 = splaty(uniform<float4>::native_tan_coefficients0);
        float4 const t2 = splatz(uniform<float4>::native_tan_coefficients0);
        float4 const t3 = splatw(uniform<float4>::native_tan_coefficients0);
        float4 const t4 = splatx(uniform<float4>::native_tan_coefficients1);
        float4 const c1 = splaty(uniform<float4>::native_tan_coefficients1);
        float4 const c2 = splatz(uniform<float4>::native_tan_coefficients1);
        float4 const c3 = splatw(uniform<float4>::native_tan_coefficients1);
        float4 rt, rc, r, s, t, u;
        int4 m;

        // decompose octant of u, let s = sign(u), let t = |u| if |u| < Pi/4 else Pi/2 - |u|
        s = copysign(one, v);
        u = fabs(v);
        m = isless(u, quarter_pi);
        t = sub(half_pi, u);
        t = select(t, u, m);

        // tan(x) = s*P(t) over [0,Pi/4] where P(t) = t + t1*t^3 + t2*t^5 + t3*t^7 + ...
        // cot(x) = s*Q(t) over [Pi/4,Pi/2] where Q(t) = t^-1 + c1*t + c2*t^3 + c3*t^5 + ... 
        u = mul(t, t);
        t = mul(t, s);
        s = mul(u, t);
        r = add(t, uniform<float4>::epsilon);
        r = half_recip(r);
        rt = fma(t4, u, t3);
        rt = fma(rt, u, t2);
        rc = fma(c3, u, c2);
        rt = fma(rt, u, t1);
        rc = fma(rc, u, c1);
        rt = fma(rt, s, t);
        rc = fma(rc, t, r);
        rt = select(rc, rt, m);
        return rt;
    }

    inline UPALWAYSINLINE
    float4 native_acos(float4_cval_t v) noexcept {
        float4 const pi = splaty(uniform<float4>::sincos_range_constants);
        float4 const one_plus_epsilon = splatx(uniform<float4>::native_acos_coefficients);
        float4 const c1 = splaty(uniform<float4>::native_acos_coefficients);
        float4 const c2 = splatz(uniform<float4>::native_acos_coefficients);
        float4 const c3 = splatw(uniform<float4>::native_acos_coefficients);
        float4 q, r, s, t, u;
        int4 m;

        // decompose into positive or negative, let u = |v|
        u = fabs(v);
        m = isless(v, zero<float4>());

        // acos(v) = P(1-u) / sqrt(2*(1-u)) over [0,1] where P(x) = 2x + c1*x^2 + c2*x^3 + c3*x^4 + ...
        u = sub(one_plus_epsilon, u);
        t = add(u, u);
        s = mul(u, u);
        q = half_rsqrt(t);
        r = fma(c3, u, c2);
        r = fma(r, u, c1);
        r = fma(r, s, t);
        r = mul(r, q);

        // select result based on quadrant
        q = sub(pi, r);
        r = select(r, q, m);
        return r;
    }

    inline UPALWAYSINLINE
    float4 native_asin(float4_cval_t v) noexcept {
        float4 const half_pi = splatx(uniform<float4>::sincos_range_constants);
        float4 const pi = splaty(uniform<float4>::sincos_range_constants);
        float4 const one_plus_epsilon = splatx(uniform<float4>::native_acos_coefficients);
        float4 const c1 = splaty(uniform<float4>::native_acos_coefficients);
        float4 const c2 = splatz(uniform<float4>::native_acos_coefficients);
        float4 const c3 = splatw(uniform<float4>::native_acos_coefficients);
        float4 q, r, s, t, u;
        int4 m;

        // decompose into positive or negative, let u = |v|
        u = fabs(v);
        m = isless(v, zero<float4>());

        // acos(v) = P(1-u) / sqrt(2*(1-u)) over [0,1] where P(x) = 2x + c1*x^2 + c2*x^3 + c3*x^4 + ...
        u = sub(one_plus_epsilon, u);
        t = add(u, u);
        s = mul(u, u);
        q = half_rsqrt(t);
        r = fma(c3, u, c2);
        r = fma(r, u, c1);
        r = fma(r, s, t);
        r = mul(r, q);

        // select result based on quadrant
        q = sub(pi, r);
        r = select(r, q, m);

        // asin(v) = Pi/2 - acos(v)
        r = sub(half_pi, r);
        return r;
    }

    inline UPALWAYSINLINE
    float4 half_cos(float4_cval_t v) noexcept {
        float4 const pi = splaty(uniform<float4>::sincos_range_constants);
        float4 const two_pi = splatz(uniform<float4>::sincos_range_constants);
        float4 const rcp_two_pi = splatw(uniform<float4>::sincos_range_constants);
        float4 u;
        u = add(v, pi);
        u = mul(u, rcp_two_pi);
        u = floor(u);
        u = fnma(u, two_pi, v);
        u = native_cos(u);
        return u;
    }

    inline UPALWAYSINLINE
    float4 half_sin(float4_cval_t v) noexcept {
        float4 const pi = splaty(uniform<float4>::sincos_range_constants);
        float4 const two_pi = splatz(uniform<float4>::sincos_range_constants);
        float4 const rcp_two_pi = splatw(uniform<float4>::sincos_range_constants);
        float4 u;
        u = add(v, pi);
        u = mul(u, rcp_two_pi);
        u = floor(u);
        u = fnma(u, two_pi, v);
        u = native_sin(u);
        return u; 
    }

    inline UPALWAYSINLINE
    float4 half_sincos(float4_cval_t v, float4* cosval) noexcept {
        float4 const pi = splaty(uniform<float4>::sincos_range_constants);
        float4 const two_pi = splatz(uniform<float4>::sincos_range_constants);
        float4 const rcp_two_pi = splatw(uniform<float4>::sincos_range_constants);
        float4 u;
        u = add(v, pi);
        u = mul(u, rcp_two_pi);
        u = floor(u);
        u = fnma(u, two_pi, v);
        u = native_sincos(u, cosval);
        return u;
    }

    inline UPALWAYSINLINE
    float4 half_tan(float4_cval_t v) noexcept {
        float4 const half_pi = splaty(uniform<float4>::tan_range_constants);
        float4 const pi = splatz(uniform<float4>::tan_range_constants);
        float4 const rcp_pi = splatw(uniform<float4>::tan_range_constants);
        float4 u;
        u = add(v, half_pi);
        u = mul(u, rcp_pi);
        u = floor(u);
        u = fnma(u, pi, v);
        u = native_tan(u);
        return u;
    }

    inline UPALWAYSINLINE
    float4 cos(float4_cval_t v) noexcept {
        float4 const half_pi = splatx(uniform<float4>::sincos_range_constants);
        float4 const pi = splaty(uniform<float4>::sincos_range_constants);
        float4 const two_pi = splatz(uniform<float4>::sincos_range_constants);
        float4 const rcp_two_pi = splatw(uniform<float4>::sincos_range_constants);
        float4 const one = splatx(uniform<float4>::cos_coefficients0);
        float4 const c1 = splaty(uniform<float4>::cos_coefficients0);
        float4 const c2 = splatz(uniform<float4>::cos_coefficients0);
        float4 const c3 = splatw(uniform<float4>::cos_coefficients0);
        float4 const c4 = splatx(uniform<float4>::cos_coefficients1);
        float4 const c5 = splaty(uniform<float4>::cos_coefficients1);
        float4 const c6 = splatz(uniform<float4>::cos_coefficients1);
        float4 const c7 = splatw(uniform<float4>::cos_coefficients1);
        float4 r, s, t, u;
        int4 m;

        // let u = v reduced to [-Pi,Pi]
        u = add(v, pi);
        u = mul(u, rcp_two_pi);
        u = floor(u);
        u = fnma(u, two_pi, v);

        // decompose quadrant of u, let s = sign(cos(v)), let t = |u| reflected at Pi/2
        u = fabs(u);
        s = neg(one);
        m = islessequal(u, half_pi);
        t = sub(pi, u);
        s = select(s, one, m);
        t = select(t, u, m);

        // evaluate polynomial s*P(t) over [0,Pi/2] where P(t) = 1 + c1*t^2 + c2*t^4 + c3*t^6 + ...
        u = mul(t, t);
        t = mul(u, s);
        r = fma(c7, u, c6);
        r = fma(r, u, c5);
        r = fma(r, u, c4);
        r = fma(r, u, c3);
        r = fma(r, u, c2);
        r = fma(r, u, c1);
        r = fma(r, t, s);
        return r;
    }

    inline UPALWAYSINLINE
    float4 sin(float4_cval_t v) noexcept {
        float4 const half_pi = splatx(uniform<float4>::sincos_range_constants);
        float4 const pi = splaty(uniform<float4>::sincos_range_constants);
        float4 const two_pi = splatz(uniform<float4>::sincos_range_constants);
        float4 const rcp_two_pi = splatw(uniform<float4>::sincos_range_constants);
        float4 const one = splatx(uniform<float4>::sin_coefficients0);
        float4 const c1 = splaty(uniform<float4>::sin_coefficients0);
        float4 const c2 = splatz(uniform<float4>::sin_coefficients0);
        float4 const c3 = splatw(uniform<float4>::sin_coefficients0);
        float4 const c4 = splatx(uniform<float4>::sin_coefficients1);
        float4 const c5 = splaty(uniform<float4>::sin_coefficients1);
        float4 const c6 = splatz(uniform<float4>::sin_coefficients1);
        float4 const c7 = splatw(uniform<float4>::sin_coefficients1);
        float4 r, s, t, u;
        int4 m;

        // let u = v reduced to [-Pi,Pi]
        u = add(v, pi);
        u = mul(u, rcp_two_pi);
        u = floor(u);
        u = fnma(u, two_pi, v);

        // decompose quadrant of u, let s = sign(u), let t = |u| reflected at Pi/2
        s = copysign(one, u);
        u = fabs(u);
        m = islessequal(u, half_pi);
        t = sub(pi, u);
        t = select(t, u, m);

        // evaluate polynomial s*P(t) over [0,Pi/2] where P(t) = t + c1*t^3 + c2*t^5 + c3*t^7 + ...
        u = mul(t, t);
        t = mul(t, s);
        s = mul(u, t);
        r = fma(c7, u, c6);
        r = fma(r, u, c5);
        r = fma(r, u, c4);
        r = fma(r, u, c3);
        r = fma(r, u, c2);
        r = fma(r, u, c1);
        r = fma(r, s, t);
        return r; 
    }

    inline UPALWAYSINLINE
    float4 sincos(float4_cval_t v, float4* cosval) noexcept {
        float4 const half_pi = splatx(uniform<float4>::sincos_range_constants);
        float4 const pi = splaty(uniform<float4>::sincos_range_constants);
        float4 const two_pi = splatz(uniform<float4>::sincos_range_constants);
        float4 const rcp_two_pi = splatw(uniform<float4>::sincos_range_constants);
        float4 const one = splatx(uniform<float4>::cos_coefficients0);
        float4 const c1 = splaty(uniform<float4>::cos_coefficients0);
        float4 const c2 = splatz(uniform<float4>::cos_coefficients0);
        float4 const c3 = splatw(uniform<float4>::cos_coefficients0);
        float4 const c4 = splatx(uniform<float4>::cos_coefficients1);
        float4 const c5 = splaty(uniform<float4>::cos_coefficients1);
        float4 const c6 = splatz(uniform<float4>::cos_coefficients1);
        float4 const c7 = splatw(uniform<float4>::cos_coefficients1);
        float4 const s1 = splaty(uniform<float4>::sin_coefficients0);
        float4 const s2 = splatz(uniform<float4>::sin_coefficients0);
        float4 const s3 = splatw(uniform<float4>::sin_coefficients0);
        float4 const s4 = splatx(uniform<float4>::sin_coefficients1);
        float4 const s5 = splaty(uniform<float4>::sin_coefficients1);
        float4 const s6 = splatz(uniform<float4>::sin_coefficients1);
        float4 const s7 = splatw(uniform<float4>::sin_coefficients1);
        float4 rs, rc, ss, sc, s, t, u;
        int4 m;

        // let u = v reduced to [-Pi,Pi]
        u = add(v, pi);
        u = mul(u, rcp_two_pi);
        u = floor(u);
        u = fnma(u, two_pi, v);

        // decompose quadrant of u, let s = sign(u), let t = |u| reflected at Pi/2
        ss = copysign(one, u);
        u = fabs(u);
        sc = neg(one); 
        m = islessequal(u, half_pi);
        t = sub(pi, u);
        sc = select(sc, one, m);
        t = select(t, u, m);

        // cos(v) = ss*Q(t) over [0,Pi/2] where Q(t) = t + c1*t^3 + c2*t^5 + c3*t^7 + ...
        // sin(v) = sc*P(t) over [0,Pi/2] where P(t) = 1 + c1*t^2 + c2*t^4 + c3*t^6 + ...
        u = mul(t, t);
        t = mul(t, ss);
        s = mul(u, sc);
        ss = mul(u, t);
        rc = fma(c7, u, c6);
        rs = fma(s7, u, s6);
        rc = fma(rc, u, c5);
        rs = fma(rs, u, s5);
        rc = fma(rc, u, c4);
        rs = fma(rs, u, s4);
        rc = fma(rc, u, c3);
        rs = fma(rs, u, s3);
        rc = fma(rc, u, c2);
        rs = fma(rs, u, s2);
        rc = fma(rc, u, c1);
        rs = fma(rs, u, s1);
        rc = fma(rc, s, sc);
        rs = fma(rs, ss, t);
        *cosval = rc;
        return rs;
    }

    inline UPALWAYSINLINE
    float4 tan(float4_cval_t v) noexcept {
        float4 const quarter_pi = splatx(uniform<float4>::tan_range_constants);
        float4 const half_pi = splaty(uniform<float4>::tan_range_constants);
        float4 const pi = splatz(uniform<float4>::tan_range_constants);
        float4 const rcp_pi = splatw(uniform<float4>::tan_range_constants);
        float4 const one = splatx(uniform<float4>::tan_coefficients0);
        float4 const t1 = splatz(uniform<float4>::tan_coefficients0);
        float4 const c1 = splatw(uniform<float4>::tan_coefficients0);
        float4 const t2 = splatx(uniform<float4>::tan_coefficients1);
        float4 const c2 = splaty(uniform<float4>::tan_coefficients1);
        float4 const t3 = splatz(uniform<float4>::tan_coefficients1);
        float4 const c3 = splatw(uniform<float4>::tan_coefficients1);
        float4 const t4 = splatx(uniform<float4>::tan_coefficients2);
        float4 const c4 = splaty(uniform<float4>::tan_coefficients2);
        float4 const t5 = splatz(uniform<float4>::tan_coefficients2);
        float4 const c5 = splatw(uniform<float4>::tan_coefficients2);
        float4 const t6 = splatx(uniform<float4>::tan_coefficients3);
        float4 const c6 = splaty(uniform<float4>::tan_coefficients3);
        float4 const t7 = splatz(uniform<float4>::tan_coefficients3);
        float4 const c7 = splatw(uniform<float4>::tan_coefficients3);
        float4 rt, rc, r, s, t, u;
        int4 m;

        // let u = v reduced to [-Pi/2,Pi/2]
        u = add(v, half_pi);
        u = mul(u, rcp_pi);
        u = floor(u);
        u = fnma(u, pi, v);

        // decompose octant of u, let s = sign(u), let t = |u| if |u| < Pi/4 else Pi/2 - |u|
        s = copysign(one, u);
        u = fabs(u);
        m = islessequal(u, quarter_pi);
        t = sub(half_pi, u);
        t = select(t, u, m);

        // tan(x) = s*P(t) over [0,Pi/4] where P(t) = t + t1*t^3 + t2*t^5 + t3*t^7 + ...
        // cot(x) = s*Q(t) over [Pi/4,Pi/2] where Q(t) = t^-1 + c1*t + c2*t^3 + c3*t^5 + ... 
        u = mul(t, t);
        t = mul(t, s);
        s = mul(u, t);
        r = add(t, uniform<float4>::epsilon);
        r = recip(r);
        rt = fma(t7, u, t6);
        rc = fma(c7, u, c6);
        rt = fma(rt, u, t5);
        rc = fma(rc, u, c5);
        rt = fma(rt, u, t4);
        rc = fma(rc, u, c4);
        rt = fma(rt, u, t3);
        rc = fma(rc, u, c3);
        rt = fma(rt, u, t2);
        rc = fma(rc, u, c2);
        rt = fma(rt, u, t1);
        rc = fma(rc, u, c1);
        rt = fma(rt, s, t);
        rc = fma(rc, t, r);
        rt = select(rc, rt, m);
        return rt; 
    }

    inline UPALWAYSINLINE
    float4 cospi(float4_cval_t v) noexcept {
        float4 r = mul(v, uniform<float4>::pi);
        r = cos(r);
        return r;
    }

    inline UPALWAYSINLINE
    float4 sinpi(float4_cval_t v) noexcept {
        float4 r = mul(v, uniform<float4>::pi);
        r = sin(r);
        return r;
    }

    inline UPALWAYSINLINE
    float4 tanpi(float4_cval_t v) noexcept {
        float4 r = mul(v, uniform<float4>::pi);
        r = tan(r);
        return r;
    }

    extern LIBUPCOREAPI float4 acos(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 acosh(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 acospi(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 asin(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 asinh(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 asinpi(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 atan(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 atanh(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 atanpi(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 cbrt(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 cosh(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 erfc(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 erf(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 exp(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 exp2(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 exp10(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 expm1(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 log(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 log2(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 log10(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 log1p(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 logb(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 pow(float4_cval_t v1, float4_cval_t v2) noexcept;
    extern LIBUPCOREAPI float4 pown(float4_cval_t v, int n) noexcept;
    extern LIBUPCOREAPI float4 sinh(float4_cval_t v) noexcept;
    extern LIBUPCOREAPI float4 tanh(float4_cval_t v) noexcept;
}}

#endif
